#![allow(dead_code)] // parse/Layout used by TUI (not yet implemented); generate/append_new already used

//! Parser and writer for `tangle/layout.tngl`.
//!
//! The layout file stores x/y canvas positions for each node. It is
//! auto-generated and safe to gitignore. When absent the TUI uses its
//! own auto-layout algorithm.

use std::collections::HashMap;

// ---------------------------------------------------------------------------
// Layout constants (simple grid)
// ---------------------------------------------------------------------------

const COLS: usize = 5;
const X_START: i32 = 80;
const Y_START: i32 = 80;
const X_STEP: i32 = 160;
const Y_STEP: i32 = 120;

pub const HEADER: &str = "# Auto-generated by tngl — safe to gitignore";

// ---------------------------------------------------------------------------
// Types
// ---------------------------------------------------------------------------

#[derive(Debug, Clone, PartialEq, Eq)]
pub struct NodePos {
    pub path: String,
    pub x: i32,
    pub y: i32,
}

#[derive(Debug, Default, Clone)]
pub struct Layout {
    pub positions: Vec<NodePos>,
}

impl Layout {
    /// Return the (x, y) position for `path`, if present.
    pub fn get(&self, path: &str) -> Option<(i32, i32)> {
        self.positions
            .iter()
            .find(|p| p.path == path)
            .map(|p| (p.x, p.y))
    }

    pub fn len(&self) -> usize {
        self.positions.len()
    }

    pub fn is_empty(&self) -> bool {
        self.positions.is_empty()
    }
}

// ---------------------------------------------------------------------------
// Grid positioning
// ---------------------------------------------------------------------------

/// Return the canonical (x, y) for the node at `index` in the grid.
pub fn position_for_index(index: usize) -> (i32, i32) {
    let col = index % COLS;
    let row = index / COLS;
    (X_START + col as i32 * X_STEP, Y_START + row as i32 * Y_STEP)
}

// ---------------------------------------------------------------------------
// Generation
// ---------------------------------------------------------------------------

/// Generate a fresh `layout.tngl` string for the given paths.
pub fn generate(paths: &[String]) -> String {
    let mut lines = vec![HEADER.to_string()];
    for (i, path) in paths.iter().enumerate() {
        let (x, y) = position_for_index(i);
        lines.push(format_position(path, x, y));
    }
    lines.join("\n") + "\n"
}

/// Append positions for `new_paths` to an existing layout file string.
///
/// `existing_count` is the number of nodes already in the layout — used to
/// continue the grid numbering so new nodes don't overlap existing ones.
pub fn append_new(existing: &str, new_paths: &[String], existing_count: usize) -> String {
    if new_paths.is_empty() {
        return existing.to_string();
    }
    let mut result = existing.trim_end_matches('\n').to_string();
    for (i, path) in new_paths.iter().enumerate() {
        let (x, y) = position_for_index(existing_count + i);
        result.push('\n');
        result.push_str(&format_position(path, x, y));
    }
    result + "\n"
}

/// Reconcile layout entries against the current graph node set.
///
/// - Keeps existing positions for nodes that still exist.
/// - Drops positions for removed nodes.
/// - Assigns grid positions for newly added nodes.
pub fn reconcile(existing: &str, paths: &[String]) -> String {
    let existing_layout = parse(existing);
    let mut by_path: HashMap<&str, (i32, i32)> = HashMap::new();
    for pos in &existing_layout.positions {
        by_path.insert(pos.path.as_str(), (pos.x, pos.y));
    }

    let mut lines = vec![HEADER.to_string()];
    for (i, path) in paths.iter().enumerate() {
        let (x, y) = by_path
            .get(path.as_str())
            .copied()
            .unwrap_or_else(|| position_for_index(i));
        lines.push(format_position(path, x, y));
    }

    lines.join("\n") + "\n"
}

fn format_position(path: &str, x: i32, y: i32) -> String {
    format!("{:<40} x:{:<6} y:{}", path, x, y)
}

// ---------------------------------------------------------------------------
// Parsing
// ---------------------------------------------------------------------------

/// Parse a `layout.tngl` file. Malformed lines are silently skipped.
pub fn parse(input: &str) -> Layout {
    let mut positions = Vec::new();
    for line in input.lines() {
        let trimmed = line.trim();
        if trimmed.is_empty() || trimmed.starts_with('#') {
            continue;
        }
        if let Some(pos) = parse_line(trimmed) {
            positions.push(pos);
        }
    }
    Layout { positions }
}

fn parse_line(line: &str) -> Option<NodePos> {
    // Format: "<path>   x:<N>  y:<M>"
    // Find the last occurrence of x: and y: tokens.
    let x_pos = line.find("x:")?;
    let y_pos = line.find("y:")?;
    if y_pos <= x_pos {
        return None; // unexpected order
    }

    let path = line[..x_pos].trim().to_string();
    if path.is_empty() {
        return None;
    }

    let x: i32 = line[x_pos + 2..].split_whitespace().next()?.parse().ok()?;
    let y: i32 = line[y_pos + 2..].split_whitespace().next()?.parse().ok()?;

    Some(NodePos { path, x, y })
}

// ---------------------------------------------------------------------------
// Tests
// ---------------------------------------------------------------------------

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn generate_empty() {
        let out = generate(&[]);
        assert_eq!(out, format!("{}\n", HEADER));
    }

    #[test]
    fn generate_single_node() {
        let paths = vec!["src/main.rs".to_string()];
        let out = generate(&paths);
        assert!(out.contains("src/main.rs"));
        assert!(out.contains("x:80"));
        assert!(out.contains("y:80"));
    }

    #[test]
    fn generate_grid_layout() {
        // 6 nodes: first row of 5, second row starts at y:200
        let paths: Vec<String> = (0..6).map(|i| format!("node{}.rs", i)).collect();
        let out = generate(&paths);
        let layout = parse(&out);
        assert_eq!(layout.positions.len(), 6);
        // First node: col 0, row 0
        assert_eq!(layout.get("node0.rs"), Some((80, 80)));
        // Sixth node: col 0, row 1
        assert_eq!(layout.get("node5.rs"), Some((80, 200)));
    }

    #[test]
    fn parse_roundtrip() {
        let paths: Vec<String> = vec!["a.rs".into(), "b/".into(), "c.rs".into()];
        let generated = generate(&paths);
        let layout = parse(&generated);
        assert_eq!(layout.positions.len(), 3);
        assert_eq!(layout.get("a.rs"), Some(position_for_index(0)));
        assert_eq!(layout.get("b/"), Some(position_for_index(1)));
    }

    #[test]
    fn parse_skips_comments_and_blanks() {
        let input = "# header\n\na.rs       x:80   y:80\n# comment\nb.rs       x:240  y:80\n";
        let layout = parse(input);
        assert_eq!(layout.positions.len(), 2);
    }

    #[test]
    fn parse_skips_malformed_lines() {
        let input = "bad line no coords\na.rs  x:80  y:80\n";
        let layout = parse(input);
        assert_eq!(layout.positions.len(), 1);
    }

    #[test]
    fn append_new_adds_at_end() {
        let paths = vec!["a.rs".to_string()];
        let existing = generate(&paths);
        let new_paths = vec!["b.rs".to_string()];
        let updated = append_new(&existing, &new_paths, 1);
        let layout = parse(&updated);
        assert_eq!(layout.positions.len(), 2);
        assert!(layout.get("b.rs").is_some());
        // b.rs is at index 1 — second position in grid
        assert_eq!(layout.get("b.rs"), Some(position_for_index(1)));
    }

    #[test]
    fn append_new_empty() {
        let existing = generate(&["a.rs".to_string()]);
        let updated = append_new(&existing, &[], 1);
        assert_eq!(updated, existing);
    }

    #[test]
    fn header_in_generate() {
        let out = generate(&["a.rs".to_string()]);
        assert!(out.starts_with(HEADER));
    }

    #[test]
    fn reconcile_keeps_existing_positions_and_drops_removed() {
        let existing = "\
# Auto-generated by tngl — safe to gitignore
a.rs                                     x:500    y:500
b.rs                                     x:600    y:600
";
        let updated = reconcile(existing, &["b.rs".into(), "c.rs".into()]);
        let parsed = parse(&updated);

        // b.rs keeps its existing position.
        assert_eq!(parsed.get("b.rs"), Some((600, 600)));
        // a.rs removed from layout.
        assert!(parsed.get("a.rs").is_none());
        // c.rs gets a generated fallback position.
        assert!(parsed.get("c.rs").is_some());
    }
}
